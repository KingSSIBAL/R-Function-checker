# ============================================================================
# AUTOGRADER PACKAGE - R WRAPPERS FOR C++ FUNCTIONS
# ============================================================================
#
# File: RcppExports.R
# Purpose: R wrappers for Rcpp exported C++ functions
#
# This file is partially auto-generated by Rcpp::compileAttributes()
# and extended with additional wrapper functions.
#
# Author: Reijel Agub (rcagub@up.edu.ph)
# Version: 0.4.0
# License: MIT
#
# ============================================================================

# ============================================================================
# CORE COMPARISON FUNCTIONS
# ============================================================================

#' Fast object comparison
#' @param obj1 First R object
#' @param obj2 Second R object  
#' @param tolerance Numeric tolerance for floating-point comparisons
#' @return Logical indicating if objects are equal
#' @keywords internal
.cpp_compare_fast <- function(obj1, obj2, tolerance = 1e-10) {
    .Call(`_autograder_cpp_compare_fast`, obj1, obj2, tolerance)
}

#' Legacy comparison (backward compatibility)
#' @param obj1 First R object
#' @param obj2 Second R object
#' @return Logical indicating if objects are identical
#' @keywords internal
.cpp_compare_identical <- function(obj1, obj2) {
    .Call(`_autograder_cpp_compare_identical`, obj1, obj2)
}

#' Detailed comparison with difference information
#' @param obj1 First R object
#' @param obj2 Second R object
#' @param tolerance Comparison tolerance
#' @return List with equal, first_diff, and description
#' @keywords internal
.cpp_compare_detailed <- function(obj1, obj2, tolerance = 1e-10) {
    .Call(`_autograder_cpp_compare_detailed`, obj1, obj2, tolerance)
}

#' Find positions where vectors differ
#' @param v1 First numeric vector
#' @param v2 Second numeric vector
#' @param tolerance Comparison tolerance
#' @param max_diffs Maximum differences to return
#' @return Integer vector of differing positions (1-based)
#' @keywords internal
.cpp_find_differences <- function(v1, v2, tolerance = 1e-10, max_diffs = 10L) {
    .Call(`_autograder_cpp_find_differences`, v1, v2, tolerance, max_diffs)
}

# ============================================================================
# NETWORK FUNCTIONS
# ============================================================================

#' Fetch function content from repository
#' @param function_name Name of function to fetch
#' @return Character vector of file lines
#' @keywords internal
.cpp_fetch_function_content <- function(function_name) {
    .Call(`_autograder_cpp_fetch_function_content`, function_name)
}

#' Fetch problems list from repository
#' @return Character vector of problems file content
#' @keywords internal
.cpp_fetch_problems_list <- function() {
    .Call(`_autograder_cpp_fetch_problems_list`)
}

#' Check internet connectivity
#' @return Logical indicating if internet is available
#' @keywords internal
.cpp_has_internet <- function() {
    .Call(`_autograder_cpp_has_internet`)
}

# ============================================================================
# VALIDATION FUNCTIONS
# ============================================================================

#' Validate function name
#' @param name Function name to validate
#' @return Logical indicating if name is valid
#' @keywords internal
.cpp_validate_function_name <- function(name) {
    .Call(`_autograder_cpp_validate_function_name`, name)
}

# ============================================================================
# FORMATTING FUNCTIONS
# ============================================================================

#' Format R object for display
#' @param obj R object to format
#' @param max_length Maximum output length
#' @return Formatted string
#' @keywords internal
.cpp_format_output <- function(obj, max_length = 200L) {
    .Call(`_autograder_cpp_format_output`, obj, max_length)
}

#' Get R object type name
#' @param obj R object
#' @return Type name string
#' @keywords internal
.cpp_get_type <- function(obj) {
    .Call(`_autograder_cpp_get_type`, obj)
}

# ============================================================================
# ENCRYPTION FUNCTIONS (NEW)
# ============================================================================

#' Encrypt a string
#' 
#' Encrypts a string using AES S-box based encryption.
#' 
#' @param plaintext Text to encrypt
#' @param key Optional encryption key (uses default if empty)
#' @return Hex-encoded encrypted string
#' @keywords internal
.cpp_encrypt <- function(plaintext, key = "") {
    .Call(`_autograder_cpp_encrypt`, plaintext, key)
}

#' Decrypt a string
#' 
#' Decrypts a hex-encoded encrypted string.
#' 
#' @param ciphertext Hex-encoded encrypted string
#' @param key Optional encryption key (uses default if empty)
#' @return Decrypted plaintext
#' @keywords internal
.cpp_decrypt <- function(ciphertext, key = "") {
    .Call(`_autograder_cpp_decrypt`, ciphertext, key)
}

#' Encrypt to base64
#' 
#' Encrypts a string and returns base64-encoded result.
#' 
#' @param plaintext Text to encrypt
#' @param key Optional encryption key
#' @return Base64-encoded encrypted string
#' @keywords internal
.cpp_encrypt_base64 <- function(plaintext, key = "") {
    .Call(`_autograder_cpp_encrypt_base64`, plaintext, key)
}

#' Decrypt from base64
#' 
#' Decrypts a base64-encoded encrypted string.
#' 
#' @param ciphertext Base64-encoded encrypted string
#' @param key Optional encryption key
#' @return Decrypted plaintext
#' @keywords internal
.cpp_decrypt_base64 <- function(ciphertext, key = "") {
    .Call(`_autograder_cpp_decrypt_base64`, ciphertext, key)
}

#' Derive encryption key
#' 
#' Derives a key from multiple factors using S-box transformation.
#' 
#' @param factors Character vector of key factors
#' @param key_length Desired key length (default 32 for 256-bit)
#' @return Hex-encoded derived key
#' @keywords internal
.cpp_derive_key <- function(factors, key_length = 32L) {
    .Call(`_autograder_cpp_derive_key`, factors, key_length)
}

#' Generate random key
#' 
#' Generates a cryptographically random key.
#' 
#' @param length Key length in bytes (default 32)
#' @return Hex-encoded random key
#' @keywords internal
.cpp_generate_key <- function(length = 32L) {
    .Call(`_autograder_cpp_generate_key`, length)
}

#' Encrypt URL
#' 
#' Encrypts a URL for secure storage.
#' 
#' @param url URL to encrypt
#' @return Encrypted URL string
#' @keywords internal
.cpp_encrypt_url <- function(url) {
    .Call(`_autograder_cpp_encrypt_url`, url)
}

#' Decrypt URL
#' 
#' Decrypts an encrypted URL.
#' 
#' @param encrypted_url Encrypted URL string
#' @return Decrypted URL
#' @keywords internal
.cpp_decrypt_url <- function(encrypted_url) {
    .Call(`_autograder_cpp_decrypt_url`, encrypted_url)
}

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

#' Get autograder version
#' @return Version string
#' @keywords internal
.cpp_get_version <- function() {
    .Call(`_autograder_cpp_get_version`)
}

# ============================================================================
# PUBLIC ENCRYPTION API
# ============================================================================

#' Encrypt text
#' 
#' Encrypts text using the autograder's encryption system.
#' This function provides a simple interface for encrypting sensitive data.
#' 
#' @param text Character string to encrypt
#' @param key Optional custom key (uses default if not provided)
#' @param encoding Output encoding: "hex" (default) or "base64"
#' 
#' @return Encrypted string in specified encoding
#' 
#' @examples
#' \dontrun{
#' # Basic encryption
#' encrypted <- encrypt_text("my secret data")
#' 
#' # With custom key
#' encrypted <- encrypt_text("my secret", key = "my-custom-key")
#' 
#' # Base64 encoding
#' encrypted <- encrypt_text("my secret", encoding = "base64")
#' }
#' 
#' @export
encrypt_text <- function(text, key = "", encoding = c("hex", "base64")) {
    encoding <- match.arg(encoding)
    
    if (!is.character(text) || length(text) != 1) {
        stop("text must be a single character string", call. = FALSE)
    }
    
    if (encoding == "base64") {
        .cpp_encrypt_base64(text, key)
    } else {
        .cpp_encrypt(text, key)
    }
}

#' Decrypt text
#' 
#' Decrypts text that was encrypted using encrypt_text().
#' 
#' @param ciphertext Encrypted string
#' @param key Optional custom key (must match encryption key)
#' @param encoding Input encoding: "hex" (default) or "base64"
#' 
#' @return Decrypted plaintext string
#' 
#' @examples
#' \dontrun{
#' # Decrypt hex-encoded text
#' plaintext <- decrypt_text(encrypted_data)
#' 
#' # Decrypt base64-encoded text
#' plaintext <- decrypt_text(encrypted_data, encoding = "base64")
#' }
#' 
#' @export
decrypt_text <- function(ciphertext, key = "", encoding = c("hex", "base64")) {
    encoding <- match.arg(encoding)
    
    if (!is.character(ciphertext) || length(ciphertext) != 1) {
        stop("ciphertext must be a single character string", call. = FALSE)
    }
    
    if (encoding == "base64") {
        .cpp_decrypt_base64(ciphertext, key)
    } else {
        .cpp_decrypt(ciphertext, key)
    }
}

#' Generate encryption key
#' 
#' Generates a cryptographically secure random key for encryption.
#' 
#' @param length Key length in bytes (default 32 for 256-bit key)
#' 
#' @return Hex-encoded key string
#' 
#' @examples
#' \dontrun{
#' # Generate a new key
#' my_key <- generate_key()
#' 
#' # Use the key for encryption
#' encrypted <- encrypt_text("secret", key = my_key)
#' decrypted <- decrypt_text(encrypted, key = my_key)
#' }
#' 
#' @export
generate_key <- function(length = 32L) {
    if (!is.numeric(length) || length < 1 || length > 256) {
        stop("length must be a positive integer between 1 and 256", call. = FALSE)
    }
    .cpp_generate_key(as.integer(length))
}

#' Derive key from factors
#' 
#' Derives an encryption key from multiple input factors.
#' Useful for creating deterministic keys from known values.
#' 
#' @param ... Character strings to use as key factors
#' @param length Key length in bytes (default 32)
#' 
#' @return Hex-encoded derived key
#' 
#' @examples
#' \dontrun{
#' # Derive key from username and password
#' key <- derive_key("username", "password", "salt")
#' 
#' # Use derived key for encryption
#' encrypted <- encrypt_text("data", key = key)
#' }
#' 
#' @export
derive_key <- function(..., length = 32L) {
    factors <- c(...)
    
    if (!is.character(factors) || length(factors) == 0) {
        stop("At least one character factor is required", call. = FALSE)
    }
    
    .cpp_derive_key(factors, as.integer(length))
}
